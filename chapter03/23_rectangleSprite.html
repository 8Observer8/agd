<!doctype html>
<meta charset="utf-8">
<title>Rectangle sprite</title>
<body>
<script src="library/plugins/rAF.js"></script>
<script src="library/plugins/traceur-compiler/bin/traceur.js"></script>
<script src="library/plugins/traceur-compiler/src/bootstrap.js"></script>
<script> traceur.options.experimental = true; </script>
<script type="module">

//Create a canvas element and 2D drawing context called "ctx"
let canvas = document.createElement("canvas");
canvas.setAttribute("width", "256");
canvas.setAttribute("height", "256");
canvas.style.border = "1px dashed black";
document.body.appendChild(canvas);
let ctx = canvas.getContext("2d");

//Here's some basic code to draw a rectangle
/*
ctx.strokeStyle = "black";
ctx.lineWidth = 3;
ctx.fillStyle = "rgba(128, 128, 128, 1)";
ctx.save();
ctx.globalAlpha = 0.5;
ctx.translate(128, 128);
ctx.rotate(0.5);
ctx.beginPath();
ctx.rect(-64, -64, 128, 128);
ctx.stroke();
ctx.fill();
ctx.restore();
*/

//We can make this more flexible by creating a reusable 
//sprite system 

//1. Create a sprites array to store all the sprites
let sprites = [];

//2. Create a Sprite class with general default properties 
//for all sprites 
class Sprite {
  constructor(config = {}) {
    //The sprite's position
    this.p = {
      x: 0,
      y: 0
    };
    //The sprite's velocity
    this.v = {
      x: 0,
      y: 0
    };
    //Dimensions
    this.width = 64;
    this.height = 64;
    //Orientation
    this.rotation = 0;
    //Visibility
    this.alpha = 1;
    this.visible = true;
    //Line and color
    this.strokeStyle = "black";
    this.lineWidth = 1;
    this.fillStyle = "rgba(128; 128, 128, 1)";
    //Does this sprite scroll?
    this.scroll = true;
    //Copy the configuration properties onto the new object
    Object.assign(this, config);
    //Add this object to the `sprites` array
    sprites.push(this);
  }
  //Getters that return useful points on the sprite
  get halfWidth() {
    return this.width / 2;
  }
  get halfHeight() {
    return this.height / 2;
  }
  get center() {
    return {
      x: this.p.x + this.halfWidth,
      y: this.p.y + this.halfHeight
    };
  }
  get bottom() {
    return {
      x: this.p.x + this.halfWidth,
      y: this.p.y + this.height
    };
  }
}

//Create a Rectangle class that extends Sprite
class Rectangle extends Sprite {}

//3. Create some rectangle sprites
let box = new Rectangle();

let blueBox = new Rectangle({
  p: {x: 80, y: 100},
  width: 120,
  height: 80,
  fillStyle: "rgba(105, 210, 231, 1)",
  strokeStyle: "red",
  lineWidth: 10,
  rotation: 0.5
});

//Optionally, use dot notation to create a sprite
/*
let blueBox = new Rectangle();
blueBox.p.x = 80;
blueBox.p.y = 100;
blueBox.width = 120;
blueBox.height = 80;
blueBox.fillStyle = "rgba(105, 210, 231, 1)";
blueBox.strokeStyle = "red";
blueBox.lineWidth = 10;
blueBox.rotation = 0.5;
*/ 

//4. Render the sprites

render();
function render() {
  //Clear the canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  //Display the all the sprites 
  for (let i = 0; i < sprites.length; i++) {  
    let sprite = sprites[i];
    if (sprite.visible) {
      //Save the context state
      ctx.save();
      //Display sprites that have a rectangle type
      if (sprite instanceof Rectangle) {
        ctx.strokeStyle = sprite.strokeStyle;
        ctx.lineWidth = sprite.lineWidth;
        ctx.fillStyle = sprite.fillStyle;
        ctx.globalAlpha = sprite.alpha;
        ctx.translate(
          Math.floor(sprite.center.x),
          Math.floor(sprite.center.y)
        );
        ctx.rotate(sprite.rotation);
        ctx.beginPath();
        //Draw the rectangle around the context's center point
        ctx.rect(
          Math.floor(-sprite.halfWidth), 
          Math.floor(-sprite.halfHeight), 
          sprite.width, 
          sprite.height
        );
        ctx.stroke();
        ctx.fill();
      }
      //Restore the previous context state
      ctx.restore();
    }
  }
}
</script>
</body>
